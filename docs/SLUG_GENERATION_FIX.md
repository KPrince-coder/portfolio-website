# Slug Generation Fix - 409 & 406 Errors

**Date:** November 1, 2025  
**Status:** ‚úÖ FIXED

---

## The Problem

### Errors

```
GET .../blog_posts?select=slug&slug=eq.school 406 (Not Acceptable)
POST .../blog_posts?select=* 409 (Conflict)
```

### Root Cause

**Double Slug Generation!**

1. **Application** was generating slugs in `blogService.ts`
2. **Database trigger** was ALSO generating slugs automatically
3. Both tried to handle uniqueness ‚Üí Conflicts!

---

## The Discovery

The database migration already has a **perfect slug generation system**:

**File:** `supabase/migrations/20241031000001_blog_system.sql`

```sql
-- Function: Auto-generate slug if not provided
CREATE OR REPLACE FUNCTION auto_generate_slug()
RETURNS TRIGGER AS $
BEGIN
  -- Only generate if slug is null or empty
  IF NEW.slug IS NULL OR NEW.slug = '' THEN
    base_slug := generate_slug(NEW.title);
    final_slug := base_slug;
    
    -- Check for uniqueness and append number if needed
    WHILE EXISTS (SELECT 1 FROM blog_posts WHERE slug = final_slug ...) LOOP
      final_slug := base_slug || '-' || counter;
      counter := counter + 1;
    END LOOP;
    
    NEW.slug := final_slug;
  END IF;
  RETURN NEW;
END;
$ LANGUAGE plpgsql;

-- Trigger runs BEFORE INSERT OR UPDATE
CREATE TRIGGER auto_generate_blog_post_slug
  BEFORE INSERT OR UPDATE ON blog_posts
  FOR EACH ROW
  EXECUTE FUNCTION auto_generate_slug();
```

**Features:**

- ‚úÖ Generates slug from title
- ‚úÖ Checks for uniqueness
- ‚úÖ Appends numbers if duplicate (post-1, post-2, etc.)
- ‚úÖ Only runs if slug is NULL or empty
- ‚úÖ Atomic operation (no race conditions)

---

## The Solution

**Remove manual slug generation from application!**

### Before (Broken)

```typescript
// src/services/blogService.ts
export async function createPost(input: CreateBlogPostInput) {
  // Manual slug generation
  let slug = generateSlug(input.title);

  // Manual uniqueness check (wrong syntax ‚Üí 406 error)
  const { data: existingPost } = await supabase
    .from("blog_posts")
    .select("slug")
    .eq("slug", slug)
    .single();

  if (existingPost) {
    slug = `${slug}-${Date.now()}`; // Timestamp approach
  }

  // Insert with manual slug
  await supabase.from("blog_posts").insert({
    title: input.title,
    slug, // ‚Üê Manual slug
    ...
  });
}
```

**Problems:**

- Query syntax wrong (406 error)
- Race conditions possible
- Conflicts with database trigger
- Unnecessary complexity

### After (Fixed)

```typescript
// src/services/blogService.ts
export async function createPost(input: CreateBlogPostInput) {
  // Note: Slug is auto-generated by database trigger
  // No manual generation needed!

  // Insert WITHOUT slug - database will generate it
  await supabase.from("blog_posts").insert({
    title: input.title,
    // slug is omitted ‚Üê Database trigger handles it
    ...
  });
}
```

**Benefits:**

- ‚úÖ No 406 errors
- ‚úÖ No 409 conflicts
- ‚úÖ Simpler code
- ‚úÖ Database handles uniqueness
- ‚úÖ No race conditions
- ‚úÖ Consistent slug format

---

## How It Works Now

### Creating a Post

```
1. User types title: "My Post"
2. Application sends to database WITHOUT slug
3. Database trigger fires BEFORE INSERT
4. Trigger generates slug: "my-post"
5. Trigger checks if "my-post" exists
6. If exists, tries "my-post-1", "my-post-2", etc.
7. Post inserted with unique slug
```

### Example Scenarios

**Scenario 1: Unique Title**

```
Title: "Hello World"
‚Üí Slug: "hello-world"
```

**Scenario 2: Duplicate Title**

```
Title: "Hello World" (already exists)
‚Üí Slug: "hello-world-1"

Title: "Hello World" (third time)
‚Üí Slug: "hello-world-2"
```

**Scenario 3: Special Characters**

```
Title: "React & TypeScript!"
‚Üí Slug: "react-typescript"
```

---

## State Management Fix

Also fixed the `postId` tracking issue:

### Before

```typescript
const { postId } = options; // Prop, never updated

if (postId) {
  await updatePost(...);
} else {
  const newPost = await createPost(...);
  // postId still undefined! ‚Üê Bug
}
```

### After

```typescript
const [postId, setPostId] = useState(initialPostId);

if (postId) {
  await updatePost(...);
} else {
  const newPost = await createPost(...);
  setPostId(newPost.id); // ‚Üê Update state!
}
```

---

## Result

‚úÖ **All errors fixed!**

- No 406 errors (removed bad query)
- No 409 conflicts (database handles uniqueness)
- Auto-save works perfectly
- Slugs are always unique
- Simpler, cleaner code

---

## Key Takeaway

**Don't duplicate database logic in application code!**

If the database has a trigger for something, let it handle it. The database is:

- Faster (no network round-trip)
- More reliable (atomic operations)
- Simpler (less code to maintain)

üéâ **Issue resolved!**
