# Slug Auto-Generation Trigger Migration Guide

**Date:** November 1, 2025  
**Status:** ⚠️ PENDING MIGRATION

---

## Overview

This guide explains how to migrate from client-side slug generation to database-triggered slug generation for better reliability and performance.

---

## Current Status

✅ **Migration file created:** `supabase/migrations/20241101000001_add_slug_trigger.sql`  
⚠️ **Code reverted:** Using client-side generation until migration is applied  
❌ **Migration not applied:** Need to run migration

---

## Why This Change?

### Problems with Client-Side Generation

1. **Race Conditions** - Multiple concurrent requests can create duplicate slugs
2. **Extra Queries** - Need to check uniqueness before insert
3. **Network Overhead** - Multiple round trips to database
4. **Inconsistency** - Different clients might generate slugs differently

### Benefits of Database Triggers

1. **Atomicity** - Slug generation happens within transaction
2. **Guaranteed Uniqueness** - Database enforces uniqueness
3. **Performance** - No extra queries needed
4. **Consistency** - Single source of truth
5. **Automatic** - Works for all inserts/updates

---

## Migration Steps

### Step 1: Apply Migration

```bash
# Using Supabase CLI
supabase db push

# Or manually in Supabase Dashboard
# Copy contents of supabase/migrations/20241101000001_add_slug_trigger.sql
# Paste into SQL Editor and run
```

### Step 2: Verify Trigger Works

```sql
-- Test slug generation
INSERT INTO blog_posts (user_id, title, content, status)
VALUES (
  (SELECT id FROM profiles LIMIT 1),
  'Test Post Title',
  'Test content',
  'draft'
)
RETURNING id, title, slug;

-- Should return: slug = 'test-post-title'

-- Test uniqueness
INSERT INTO blog_posts (user_id, title, content, status)
VALUES (
  (SELECT id FROM profiles LIMIT 1),
  'Test Post Title',
  'Test content',
  'draft'
)
RETURNING id, title, slug;

-- Should return: slug = 'test-post-title-1'
```

### Step 3: Update Application Code

Once migration is verified, update `src/services/blogService.ts`:

```typescript
// In createPost function, replace:
const slug = input.slug || generateSlug(input.title);

// With:
// Slug will be auto-generated by database trigger if not provided

// And in the insert:
.insert({
  user_id: user.user.id,
  title: input.title,
  // slug is omitted - database trigger will generate it
  content: input.content,
  // ...
})
```

### Step 4: Test Application

```bash
# Start dev server
npm run dev

# Test creating a post
# 1. Go to /admin
# 2. Click Blog Posts → Create New
# 3. Enter title and content
# 4. Save draft
# 5. Verify slug is generated automatically
```

---

## What the Trigger Does

### For Blog Posts

1. **On INSERT:**
   - If `slug` is NULL or empty, generates from `title`
   - Checks uniqueness, appends `-1`, `-2`, etc. if needed
   - Calculates `read_time_minutes` from content

2. **On UPDATE:**
   - If `title` changes and `slug` is NULL/empty, regenerates slug
   - Preserves existing slug if provided

### For Categories & Tags

- Automatically generates slug from `name` field
- Ensures uniqueness across all categories/tags

---

## Slug Generation Algorithm

```
1. Convert to lowercase
2. Remove special characters (keep alphanumeric, spaces, hyphens)
3. Replace spaces with hyphens
4. Remove multiple consecutive hyphens
5. Trim leading/trailing hyphens
6. Check uniqueness
7. If exists, append -1, -2, -3, etc.
```

### Examples

| Title | Generated Slug |
|-------|----------------|
| "Hello World" | `hello-world` |
| "React Hooks: A Guide" | `react-hooks-a-guide` |
| "10 Tips & Tricks!" | `10-tips-tricks` |
| "Hello World" (duplicate) | `hello-world-1` |

---

## Rollback Plan

If issues occur, rollback by:

### 1. Drop Triggers

```sql
DROP TRIGGER IF EXISTS blog_post_slug_insert_trigger ON blog_posts;
DROP TRIGGER IF EXISTS blog_post_slug_update_trigger ON blog_posts;
DROP TRIGGER IF EXISTS blog_category_slug_trigger ON blog_categories;
DROP TRIGGER IF EXISTS blog_tag_slug_trigger ON blog_tags;

DROP FUNCTION IF EXISTS auto_generate_blog_post_slug();
DROP FUNCTION IF EXISTS auto_generate_category_slug();
DROP FUNCTION IF EXISTS auto_generate_tag_slug();
DROP FUNCTION IF EXISTS generate_unique_slug(TEXT, TEXT, UUID);
```

### 2. Keep Client-Side Generation

The code is already reverted to use client-side generation, so no code changes needed.

---

## Performance Impact

### Before (Client-Side)

```
1. Generate slug in JavaScript
2. Query database to check if slug exists
3. If exists, append timestamp
4. Insert post
Total: 2 database queries
```

### After (Database Trigger)

```
1. Insert post (trigger generates slug automatically)
Total: 1 database query
```

**Result:** 50% reduction in database queries for post creation!

---

## Testing Checklist

- [ ] Migration applied successfully
- [ ] Trigger creates slugs for new posts
- [ ] Trigger handles duplicate titles (appends numbers)
- [ ] Trigger preserves custom slugs when provided
- [ ] Trigger updates slug when title changes (if slug empty)
- [ ] Trigger calculates read time correctly
- [ ] Categories get auto-generated slugs
- [ ] Tags get auto-generated slugs
- [ ] No errors in application logs
- [ ] Post creation works in admin panel
- [ ] Post editing works in admin panel

---

## FAQ

### Q: What if I want a custom slug?

**A:** Just provide the `slug` field when creating/updating. The trigger only generates if slug is NULL or empty.

```typescript
await createPost({
  title: "My Post",
  slug: "custom-slug-here", // Will use this instead of auto-generating
  content: "..."
});
```

### Q: What happens to existing posts?

**A:** Existing posts keep their current slugs. The trigger only affects new inserts and updates.

### Q: Can I change the slug generation logic?

**A:** Yes! Edit the `generate_unique_slug` function in the migration file and re-run it.

### Q: What if two posts are created at the exact same time?

**A:** The database transaction ensures one completes first, then the second gets `-1` appended. No race condition.

---

## Next Steps

1. ✅ Migration file created
2. ⏳ Apply migration to database
3. ⏳ Verify trigger works
4. ⏳ Update application code
5. ⏳ Test thoroughly
6. ⏳ Deploy to production

---

## Summary

This migration improves reliability, performance, and maintainability by moving slug generation from application code to database triggers. Once applied, post creation will be faster and more reliable.

**Status:** Ready to apply migration!
